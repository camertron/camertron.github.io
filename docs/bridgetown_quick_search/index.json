[
        {
          "id": "2021-05-21-the-case-for-service-objects",
          "title": "The Case for Service Objects",
          "collection": {
            "label": "posts",
            "name": "Posts"
          },
          "categories": "",
          "tags": "ruby, service objects, web development, rails",
          "url": "/2021/05/21/the-case-for-service-objects/",
          "content": "This article is a response to Jason Swett‚Äôs ‚ÄúBeware of ‚Äòservice objects‚Äô in Rails‚Äù blog post. In it, Jason warns of the dangers of letting service objects rob you of the benefits of object-oriented programming. I‚Äôve read Jason‚Äôs post several times, and listened to a number of discussions he‚Äôs had about service objects on his podcast, Rails with Jason.\n\nBy the way, both Jason‚Äôs blog and podcast are excellent. Go check them out right now üòä\n\nJust last week, Jason was invited onto the Remote Ruby podcast where he and the panelists discussed service objects again. Something about the converstaion struck a cord with me. I‚Äôve listened to Jason talk about his distaste for service objects for a long time. I think he‚Äôs right, but also wrong. What follows are my thoughts on the humble, oft misunderstood, service object.\n\nPublished on May 21st, 2021\n\nIntro\n\nRails has been around for a long time now. It feels weird to write this, but it‚Äôll be Rails‚Äô 20th birthday in just a few short years. For those of us who‚Äôve used the framework for a long time, 20 years feels like a pretty incredible milestone.\n\nI started using Rails ~11 years ago, pretty much straight out of college. I worked on Twitter‚Äôs International Engineering Team on the Twitter Translation Center, a Rails app that managed our large database of localized content and facilitated contributions from thousands of volunteer translators around the world. It was my first time using Ruby, and I absolutely fell in love with it. Ruby and Rails made CakePHP, the framework I was using at the time for my side projects, feel pretty clunky and outmoded. Ruby and Rails are still my favorite language and framework today, and I know many other devs who feel the same way.\n\nWhy has Rails had such staying power? I would argue there are two major reasons:\n\n\n  The Ruby and Rails communities are nonpareil in the software world, and\n  Rails keeps evolving.\n\n\nHotwire is just the latest example of the evolution Rails devs have enjoyed for the last two decades. I invite you to look back on the asset pipeline, action cable, and turbolinks as a few examples from the past that also changed the game.\n\nWe‚Äôve Evolved Too\n\nWhile the framework has changed, so have we as Rails developers. A few years ago much noise was made over the ‚Äúfat model, skinny controller‚Äù concept (in case you‚Äôre not familiar, the idea is to keep your controller code to a minimum and put all your domain logic into the model layer).\n\nIn fact, I would posit that a number of the changes in thinking we‚Äôve gone through as a community have been related to code organization. Where do you put that odd piece of code that doesn‚Äôt seem to fit in any of Rails‚Äô predefined slots?\n\nOne of the answers is to give Rails new slots:\n\n\n  The draper gem adds the app/decorators directory for ‚Äúview models,‚Äù i.e. view presenters.\n  The form objects design pattern adds the app/forms directory for handling complex forms.\n  The pundit gem adds the app/policies directory for specifying authorization rules.\n  The view_component gem adds the app/components directory for components that encapsulate view code.\n  Etc, etc.\n\n\nOf course Rails itself also adds new slots from time to time:\n\n\n  Rails 3.0 introduced concerns and the app/models/concerns folder for augmenting models.\n  Rails 4.2 introduced active job and the app/jobs folder for background jobs.\n  Also see app/assets, app/channels, etc.\n\n\nWhile all these also added awesome new features to Rails, let‚Äôs not overlook how significant it is that they introduced a bunch of additional slots to help us organize our code better. In fact, you‚Äôd probably agree that a lot of Rails‚Äô power comes from its predefined folder structure (just ask your favorite React dev üòè).\n\nService Objects\n\nService objects are yet another slot for organizing our Ruby code, albeit a fairly misunderstood one. For instance, although the community has produced a number of gems for creating service objects, we haven‚Äôt really coalesced around any one of them. That‚Äôs probably because service objects in their purest form are just Ruby classes with a fancy name.\n\nFor example, here‚Äôs a service object that creates a user:\n\nclass CreateUser\n  def self.call(params)\n    User.create(params)\n  end\nend\n\n\nNow, I hear you saying, ‚ÄúWait wait, that‚Äôs not what service objects are!‚Äù and you‚Äôre right. The term ‚Äúservice object‚Äù means different things to different people. In my opinion however, here‚Äôs what a ‚Äúservice object‚Äù is:\n\n\n  A plain ‚Äòol Ruby object with a call method.\n\n\nThat‚Äôs literally it.\n\nOk there is one other thing. You may have noticed that the name of the example service object above, CreateUser, sounds more like the name of a method than a class. That‚Äôs intentional.\n\nI like to think of service objects as representing actions.\n\nSkinny Controllers\n\n‚ÄúHey,‚Äù I hear you saying. ‚ÄúActions‚Ä¶ like in controllers?‚Äù\n\nYes! In the applications I‚Äôve worked on, service objects were extracted exclusively from controller actions.\n\nThis is the major point on which Jason and I differ. Whereas he writes about service objects as being part of the models directory, I think of them as being part of the controllers directory. In my mind, ‚Äúservices‚Äù are just miniature web applications. Service objects therefore should aid in responding to web requests.\n\nConsider again our humble CreateUser service object. We can easily imagine how the User.create call inside it could have once been part of a controller action:\n\nclass UsersController &lt; ApplicationController\n  def create\n    @user = User.create(user_params)\n\n    if @user.valid?\n      UserMailer.with(user: @user).welcome_email.deliver_later\n      redirect_to dashboard_path, notice: 'Welcome aboard!'\n    else\n      render :new\n    end\n  end\n\n  private\n\n  def user_params\n    params.require(:user).permit(:first_name, :last_name, :email_address)\n  end\nend\n\n\nNotice that the #create action creates the user, but also sends a welcome email.\n\nAs your app grows, so do your controller actions. Maybe you decide you want to register the user with your 3rd-party email/marketing system when they sign up. A few months later you decide to A/B test sending a free trial email at signup instead of the traditional welcome email:\n\nclass UsersController &lt; ApplicationController\n  def create\n    @user = User.create(user_params)\n\n    if @user.valid?\n      BrazeClient.new.register_email(@user.email_address)\n\n      if Flipper.enabled?(:free_trial_email_at_signup, @user)\n        UserMailer.with(user: @user).free_trial_email.deliver_later\n      else\n        UserMailer.with(user: @user).welcome_email.deliver_later\n      end\n\n      redirect_to dashboard_path, notice: 'Welcome aboard!'\n    else\n      render :new\n    end\n  end\n\n  private\n\n  def user_params\n    params.require(:user).permit(:first_name, :last_name, :email_address)\n  end\nend\n\n\nWhoa, that #create method is getting pretty long. More concerning though is how much logic it encapsulates - logic that can‚Äôt be reused outside the controller. In addition, I‚Äôve only shown a single action in this example. A complete RESTful controller will have seven.\n\nLet‚Äôs pull all that creation code into the service object instead:\n\nclass CreateUser\n  def self.call(params)\n    new(params).create\n  end\n\n  def initialize(params)\n    @params = params\n  end\n\n  def create\n    user.tap do |u|\n      if u.valid?\n        send_email_address_to_braze\n        send_signup_email\n      end\n    end\n  end\n\n  private\n\n  def send_email_address_to_braze\n    BrazeClient.new.register_email(user.email_address)\n  end\n\n  def send_signup_email\n    if send_free_trial_email?\n      UserMailer.with(user: user).free_trial_email.deliver_later\n    else\n      UserMailer.with(user: user).welcome_email.deliver_later\n    end\n  end\n\n  def send_free_trial_email?\n    Flipper.enabled?(:free_trial_email_at_signup, user)\n  end\n\n  def user\n    @user ||= User.create(@params)\n  end\nend\n\n\nI really like this. Not only is the public API minimal, I can hang a bunch of helper methods onto the class that I might have been hesitant to add to the controller.\n\nAnd by extracting the user creation logic into the service object, the controller now does a whole lot less:\n\nclass UsersController &lt; ApplicationController\n  def create\n    @user = CreateUser.(user_params)\n\n    if @user.valid?\n      redirect_to dashboard_path, notice: 'Welcome aboard!'\n    else\n      render :new\n    end\n  end\n\n  private\n\n  def user_params\n    params.require(:user).permit(:first_name, :last_name, :email_address)\n  end\nend\n\n\nBut skinny controllers aren‚Äôt the only benefit.\n\nBulk User Importer\n\nIn my mind, the most significant benefit of the service object approach is code reuse.\n\nLet‚Äôs say our company starts offering our services b2b and we need to create a bunch of user accounts for all the people who work at another company. We decide to add a bulk user importer to our system that‚Äôs capable of reading a CSV file and creating a bunch of user accounts all at once. This exact scenario came up at one of my previous jobs.\n\nFortunately, our user creation logic is conveniently encapsulated into a service object, so reusing it is a piece of cake:\n\nrequire 'csv'\n\nclass UserCsvFile\n  attr_reader :path\n\n  def initialize(path)\n    @path = path\n  end\n\n  def import\n    table.each do |row|\n      CreateUser.(row.to_h)\n    end\n  end\n\n  private\n\n  def table\n    @table ||= CSV.parse(File.read(path), headers: true)\n  end\nend\n\nUserCsvFile.new('/path/to/users.csv').import\n\n\nYou could copy and paste the code from the controller into the UserCsvFile class, but at what cost? Every time the controller changes, so does UserCsvFile. At some point, someone‚Äôs gonna forget to update both codepaths.\n\nThat‚Äôs‚Ä¶ all there is to it?\n\nI‚Äôm sure some of you reading this are now thoroughly fed up. Has it really taken this guy over a thousand words just to tell you about Ruby classes?\n\nWell, that‚Äôs the thing about service objects. They really can be that simple. In fact, service objects aren‚Äôt even a design pattern. They‚Äôre just a code organization tool for extracting chunks of procedural code from controller actions, i.e. ‚Äúdo this, then do this, then do this last thing.‚Äù The ‚Äúservice object‚Äù moniker is just a name. We could easily call these chunks of code ‚Äúactions‚Äù or maybe ‚Äúcommands‚Äù as Jason mentions.\n\nLoss of Object-Orientation\n\nIn his blog post, Jason makes the following assertion:\n\n\n  Service objects throw out the fundamental advantages of object-oriented programming.\n\n  ‚ÄúObjects‚Äù like this aren‚Äôt abstractions of concepts in the domain model. They‚Äôre chunks of procedural code masquerading as object-oriented code.\n\n\nHe‚Äôs absolutely right that service objects aren‚Äôt abstractions of concepts in the domain model. They exist to encapsulate procedural code. After all, controller actions tend to be procedural, so it follows that service objects are as well.\n\nThis encapsulation idea is one of the tenets of object-oriented programming; the data needed to perform the action is held by the object, and the object‚Äôs method‚Äôs (call in our case) uses that data to perform the action.\n\nAdvanced Techniques\n\nBecause service objects are just classes with basically no rules, you have the full power of the Ruby language at your disposal. Pretty much anything goes.\n\nFor example, consider the various ways our CreateUser operation can fail. Might be kinda nice to support some failure modes:\n\nclass UsersController &lt; ApplicationController\n  def create\n    CreateUser.(user_params) do |result|\n      # creation succeeded\n      result.success do |_user|\n        redirect_to dashboard_path, notice: 'Welcome aboard!'\n      end\n\n      # user is invalid\n      result.failure do |user|\n        @user = user\n        render :new\n      end\n\n      # CreateUser.() raised an error\n      result.error do |e|\n        Rollbar.error(e)\n        flash.now[:error] = 'Something went wrong, please try again'\n        render :new\n      end\n    end\n  end\n\n  private\n\n  def user_params\n    params.require(:user).permit(:first_name, :last_name, :email_address)\n  end\nend\n\n\nDang that‚Äôs nice üî•üî•üî•\n\nHere‚Äôs what the service object might look like:\n\nclass CreateUser\n  def self.call(params)\n    new(params).create\n  end\n\n  def initialize(params)\n    @params = params\n  end\n\n  def create\n    if user.valid?\n      send_email_address_to_braze\n      send_signup_email\n      Success.new(user)\n    else\n      Failure.new(user)\n    end\n  rescue Exception =&gt; e\n    Error.new(e)\n  end\n\n  private\n\n  def send_email_address_to_braze\n    BrazeClient.new.register_email(user.email_address)\n  end\n\n  def send_signup_email\n    if send_free_trial_email?\n      UserMailer.with(user: user).free_trial_email.deliver_later\n    else\n      UserMailer.with(user: user).welcome_email.deliver_later\n    end\n  end\n\n  def send_free_trial_email?\n    Flipper.enabled?(:free_trial_email_at_signup, user)\n  end\n\n  def user\n    @user ||= User.create(@params)\n  end\nend\n\n\nAnd finally here are the result classes:\n\nclass Result\n  def initialize(args)\n    @args = args\n  end\n\n  def success(&amp;block); end\n  def failure(&amp;block); end\n  def error(&amp;block); end\nend\n\nclass Success &lt; Result\n  def success(&amp;block)\n    yield *@args\n  end\nend\n\nclass Failure &lt; Result\n  def failure(&amp;block)\n    yield *@args\n  end\nend\n\nclass Error &lt; Result\n  def error(&amp;block)\n    yield *@args\n  end\nend\n\n\nConclusion\n\nI hope this article has explained why service objects deserve a place in your Rails app. Just remember to keep ‚Äòem out of your model code.\n\nDisagree? Hit me up on Twitter."
        },
        {
          "id": "2021-05-28-encapsulation-is-a-lie",
          "title": "Encapsulation is a Lie",
          "collection": {
            "label": "posts",
            "name": "Posts"
          },
          "categories": "",
          "tags": "ruby",
          "url": "/2021/05/28/encapsulation-is-a-lie/",
          "content": "In this post I respond to another of Jason Swett‚Äôs recent articles, Don‚Äôt wrap instance variables in attr_reader unless necessary. Jason, if you‚Äôre reading this please know this blog isn‚Äôt only about critiquing your writing, which I find insightful and thought-provoking. You‚Äôve really gotten me thinking lately, and I‚Äôve been meaning to start a blog for a long time anyway. Seemed like a good opportunity to finally get one going.\n\nPublished on May 28th, 2021\n\nWhat is attr_reader?\n\nIt‚Äôs common to see Ruby classes expose instance variables using a special class method called attr_reader, eg:\n\nclass Email\n  attr_reader :subject, :body\n\n  def initialize(subject, body)\n    @subject = subject\n    @body = body\n  end\nend\n\nemail = Email.new('Check this out', 'Ruby rocks')\nputs email.subject  # =&gt; prints \"Check this out\"\n\n\nAs you can see, attr_reader :name defines the #name method on our Email class. The #name method simply returns the value of the @name instance variable.\n\nRuby also features two other class methods, attr_writer and attr_accessor. The former defines a method for assigning a value to an instance variable (eg. #name=) while the latter defines both the getter and the setter (i.e. both #name and #name=).\n\nWhy would you ever do this? The basic premise is that instance variables are private, meaning nobody outside the class can get or set them. By wrapping ivars with attr_reader and friends, they are now available to the outside world.\n\nWhy Methods are Almost Always Better\n\nIn my opinion, by far the biggest benefit of attr_reader is that it exposes instance variables as methods. Why are methods better? In a word, inheritance.\n\nThere‚Äôs no way to override instance variables in Ruby. Consider an ivar-only version of our Email class from earlier (notice the addition of the #deliver_to method):\n\nrequire 'mail'\n\nclass Email\n  def initialize(subject, body)\n    @subject = subject\n    @body = body\n  end\n\n  def deliver_to(address)\n    mail = Mail.new\n    mail[:from] = 'no-reply@camerondutro.com'\n    mail[:to] = address\n    mail[:subject] = @subject\n    mail[:body] = @body\n    mail.deliver!\n  end\nend\n\n\nLet‚Äôs say I want to add a signature at the end of the email body. To do so, I‚Äôll create a new EmailWithSignature class that inherits from Email:\n\nclass EmailWithSignature &lt; Email\nend\n\n\nSomewhere in my new class, I need to append the signature to the body. I only really have two options:\n\n\n  Override #initialize and append the signature to @body.\n  Override #deliver_to so it appends the signature on send.\n\n\nNeither of these options feel particularly ‚Äúclean.‚Äù Both #initialize and #deliver_to accept arguments, and those arguments can change over time. If I override one of them, I have to make sure my derived EmailWithSignature class changes whenever Email does.\n\nIf I choose to override #deliver_to, I have to copy/paste the logic into EmailWithSignature in order to change the content of the body, or potentially reassign @body before calling super. Yuck.\n\nInstead, let‚Äôs wrap our instance variables in attr_readers (see above). Now the derived class can simply override the body method, which will always accept zero arguments:\n\nclass EmailWithSignature &lt; Email\n  def body\n    super + \"\\n\\n-Cameron Dutro\\nInternational Man of Mystery\"\n  end\nend\n\n\nMuch easier, much cleaner.\n\nThe limitations of the ivar approach have bitten me numerous times in my professional career. In most cases, requirements had changed and I found myself needing to extend an existing class. Using attr_reader would have given me the ‚Äúhooks‚Äù I needed to non-intrusively modify the class‚Äôs behavior.\n\nRemember that derived classes can call your private methods. If you‚Äôre worried about someone else messing with your encapsulated data, just make your attr_readers private:\n\nclass Email\n  attr_reader :subject, :body\n  private :subject, :body\n\n  def initialize(subject, body)\n    @subject = subject\n    @body = body\n  end\nend\n\nemail = Email.new('Check this out', 'Ruby rocks')\nputs email.subject  # =&gt; raises a NoMethodError\n\n\nHowever, I prefer to make all of mine public. That‚Äôs because I believe encapsulation doesn‚Äôt exist.\n\nThe Problem with Encapsulation\n\nIf you‚Äôve gone through any sort of formal computer science training, chances are you‚Äôve been taught the four main pillars of object-oriented programming: inheritance, abstraction, polymorphism, and encapsulation.\n\nAs you probably already know, encapsulation prevents direct access to an object‚Äôs state. In Ruby, that means preventing direct access to an object‚Äôs instance variables. The idea is that the object and the object alone should be able to mutate its state, perhaps to maintain some invariants, etc.\n\nHowever in the vast majority of object-oriented systems, much of what we think of as the internal, encapsulated state of an object is actually shared state. Let‚Äôs take a look at a class (granted, a very na√Øve one) that represents an email address:\n\nclass EmailAddress\n  def initialize(address)\n    unless address.include?('@')\n      raise InvalidAddressError, \"the address '#{address}' is invalid\"\n    end\n\n    @address = address\n  end\n\n  def user\n    @address.split('@')[0]\n  end\n\n  def host\n    @address.split('@')[1]\n  end\nend\n\n\nOur class nicely encapsulates @address. Nobody else should be able to mess with it right?\n\nWrong!\n\naddress_str = 'foo@bar.com'\naddress = EmailAddress.new(address_str)\naddress.host  # =&gt; \"bar.com\"\naddress_str.replace('woops!')\naddress.host  # =&gt; nil\n\n\nWoops! Since everything in Ruby is passed by reference, it‚Äôs entirely possible for the data given to an object to change without the object‚Äôs knowledge. In other words, encapsulation can be easily bypassed.\n\nIt doesn‚Äôt matter if we use ivars or make the attr_reader private. There‚Äôs always the chance someone else is holding on to a reference to our ‚Äúprivate‚Äù data and can mutate it at will.\n\nTo me, that‚Äôs a pretty big deal. It means encapsulation is kind of a lie. If you assign ivars in your class‚Äôs constructor from passed-in data, you might as well expose them with attr_readers. They‚Äôre basically public anyway.\n\nEncapsulating Better\n\nHold on. If encapsulation doesn‚Äôt exist, then doesn‚Äôt that call all of object-oriented programming into question?\n\nMaybe, but I‚Äôm not the right person to say one way or the other. I happen to really enjoy object-oriented programming. It fits the way my brain works.\n\nBut just like a number of aspects of software development, programming well requires discipline. I posit that large object-oriented systems stay afloat because programmers, mostly unconsciously, develop an understanding of the nuances of encapsulation and evolve habits to avoid the major pitfalls. That‚Äôs certainly been the case for me. It was only in thinking deeply about this article that I began to ask myself why, for example, reassigning instance variables feels wrong to me.\n\nTo that end, I like to follow these rules:\n\n\n  Only set instance variables once. After they are set, treat them like constants.\n  Copy objects before mutating them.\n\n\nThe goal here is to prevent our objects from changing except at well-known points in time.\n\nOnly Set Instance Variables Once\n\nIn most cases, I think reassigning instance variables is a code smell. If your object needs to change what data it references, it should have asked for different data at initialization.\n\nNOTE: Methods that use instance variables to memoize the result of a lazily evaluated expression are ok because, although the object didn‚Äôt ask for the data at initialization, it still only sets the instance variable once.\n\nThe less your object‚Äôs state changes after initialization, the less uncertainty you introduce into the system.\n\nCopy Objects Before Mutating Them\n\nConsider this classic example of pass-by-reference mayhem:\n\ndef compliment(name)\n  puts name &lt;&lt; ', you rock!'\nend\n\nname = 'Cameron'\ncompliment(name)\nname  # =&gt; \"Cameron, you rock!\"\n\n\nThe caller probably isn‚Äôt expecting compliment to mutate name.\n\nThe same principle applies to data referenced by an object‚Äôs instance variables. Mutating only copies of your data prevents these sorts of surprises.\n\nBack to attr_reader\n\nOk, but what does all this have to do with attr_reader?\n\nIn his usual erudite manner, Jason lays out the case against attr_reader with the following statement:\n\n\n  Adding a public attr_reader throws away the benefits of encapsulation\n\n  Private instance variables are useful for the same reason as private methods: because you know they‚Äôre not depended on by outside clients.\n\n  If I have a class that has an instance variable called @price, I know that I can rename that instance variable to @cost or change it to @price_cents (changing the whole meaning of the value) or even kill @price altogether. What I want to do with @price is 100% my business. This is great.\n\n\nHopefully I‚Äôve shown in this article why encapsulation is more or less a myth. There‚Äôs no way to know who else may reference the same data as your instance variables, so it very well may not be ‚Äú100% your business.‚Äù This is especially true if one of your methods returns it somehow, perhaps wrapped by another object.\n\nI do agree that adding attr_reader :price changes the class‚Äôs public interface, making it more difficult to change in the future. Unless you‚Äôre developing library code or a gem however, I think the public interface argument is fairly weak. As Jason says a few paragraphs earlier, if a naming issue causes a problem in your application, your application probably isn‚Äôt tested well enough.\n\nConclusion\n\nMy takeaway message is this: encapsulation doesn‚Äôt provide the guarantees we were taught it does. There‚Äôs no real benefit to ‚Äúhiding‚Äù data inside an object, since that data may be referenced - privately or publicly - by any number of other objects. You might as well expose your instance variables with attr_reader for the inheritance benefits.\n\nDisagree? Hit me up on Twitter."
        },
        {
          "id": "2021-07-10-why-rubys-enumerable-module-is-awesome",
          "title": "Why Ruby's Enumerable Module is Awesome",
          "collection": {
            "label": "posts",
            "name": "Posts"
          },
          "categories": "",
          "tags": "",
          "url": "/2021/07/10/why-rubys-enumerable-module-is-awesome/",
          "content": "This post was originally written in 2014 at the beginning of my tenure at Lumos Labs. At the time, I was a member of the Learning Team, an ‚Äúextracurricular‚Äù group that met bi-weekly to discuss cool things we were learning about technology. We organized tech meetups in our office space, streamed live Google IO talks over the projector during lunch, and sent out a digest email to our colleagues every two weeks with links to various learning resources. I ended up writing a few longer-form articles for these email blasts. What follows is an embellished version of one of those articles.\n\nPublished on June 11th, 2021\n\nYou‚Äôre probably familiar with the concept of ‚Äúiteration‚Äù in computer programming. It‚Äôs the idea of examining - or iterating over - each of the things in a collection.\n\nPerhaps the most obvious thing you can iterate over is an array. The elements of an array are accessed by their index, so iterating is pretty straightforward. Here‚Äôs an example in pseudocode:\n\narray = [5, 3, 8]\n\nfor i = 0 to array.length\n  do something with array[i]\nend\n\n\nThis code iterates over each item in the array. Inside the body of the loop, elements are accessed individually using the [] syntax.\n\nWe can do the same thing in Ruby using the for keyword:\n\narray = [5, 3, 8]\n\nfor i in 0...3\n  # do something with array[i]\nend\n\n\n#each\n\nThe truth is though, in 11 years writing Ruby code, I‚Äôve never, not even once, seen anyone use a for loop. Instead, Ruby programmers reach for the #each method. #each yields each element to the given block. Here‚Äôs a quick example that prints out each of the numbers in the array:\n\n[5, 3, 8].each do |number|\n  puts number\nend\n\n\nNot only is the code easier to read with #each, it‚Äôs more obvious what it does. #each abstracts away the details of the iteration logic and lets the programmer focus on their goal: handling one element at a time.\n\nSum of Integers\n\nLet‚Äôs get a little more adventurous and use Ruby to compute the sum of all the elements in our array.\n\nsum = 0\n\n[5, 3, 8].each do |number|\n  sum += number\nend\n\n\nWhen #each returns, sum will contain 16.\n\nThe Magic of #inject\n\nIt would be great if we could get rid of that extra local variable, sum. Fortunately, Ruby‚Äôs #inject method can help. Here‚Äôs how we might use it to sum up the elements in our array:\n\n[5, 3, 8].inject(0) do |sum, number|\n  sum + number\nend\n\n\nPretty cool, eh? The #inject method calls the block for each number, passing the previous result as the first argument and the next element from the array as the second argument (the previous result is simply the value returned by the block during the previous iteration).\n\nI can hear some of you saying, ‚ÄúWhoa, slow down. What just happened?!‚Äù Ok, let‚Äôs break it down step-by-step.\n\n\n  First iteration (sum is set to the initial value passed to #inject, which is 0)\n     [5, 3, 8].inject(0) do |sum, number|\n   # sum = 0 (initial value passed to #inject above)\n   # number = 5 (first element of array)\n   # 0 + 5 = 5\n   sum + number\n   # 5 becomes the return value of the block\n end\n    \n  \n  Second iteration\n     [5, 3, 8].inject(0) do |sum, number|\n   # sum = 5 (from previous iteration)\n   # number = 3 (second element of array)\n   # 5 + 3 = 8\n   sum + number\n   # 8 becomes the return value of the block\n end\n    \n  \n  Third iteration\n     [5, 3, 8].inject(0) do |sum, number|\n   # sum = 8 (from previous iteration)\n   # number = 8 (third element of array)\n   # 8 + 8 = 16\n   sum + number\n   # 16 becomes the return value of the block\n end\n    \n  \n\n\nSince there are only three elements in the array, iteration stops and the final sum of 16 is returned.\n\nEven More Magic\n\nAs it happens, there‚Äôs an even more succinct way to do this. #inject supports passing a symbol as the first argument. The symbol must be the name of a method that can be called on the elements of the array. Since we‚Äôre adding in this case, we can pass the :+ symbol, which represents the #+ method on Integer:\n\n[5, 3, 8].inject(:+)\n\n\nNo block necessary! #inject automatically keeps track of the previous value and adds it to the next element on each iteration. As above, this code produces the value 16.\n\nThe Enumerable Module\n\nThe #inject method is only one of the many methods provided by Ruby‚Äôs Enumerable module. Enumerable is included in Array, Hash, and other core classes, providing a uniform way to iterate over all the items in a collection.\n\nThis is where things get really interesting - Enumerable has a ton of cool methods. Need to process a collection in a specific or special way? Chances are there‚Äôs an Enumerable method (or methods) for it.\n\nAccordingly, let‚Äôs take a look at a couple of the other useful tools in the Enumerable toolkit.\n\nEnumerable#map\n\n#map is probably the next most commonly used Enumerable method after #each. It collects the results of the block into an array and returns it. For example, here‚Äôs how we might multiply every element in our array by 2:\n\nresult = [5, 3, 8].map do |number|\n  number * 2\nend\n\n\nAfter running this code, result will contain [10, 6, 16].\n\nEnumerable#each_slice\n\nAnother great example of Enumerable‚Äôs utility is each_slice, which yields sub arrays of the given length to the block. For example, the following code turns this flat array of ingredients into a hash:\n\nrecipe = {}.tap do |result|\n  [:eggs, 2, :carrots, 1, :bell_peppers, 3].each_slice(2) do |food, amount|\n    result[food] = amount\n  end\nend\n\n\nThe desired length of each slice is passed as the first argument to #each_slice, eg. each_slice(2) as above.\n\nAfter running this code, recipe will contain { eggs: 2, carrots: 1, bell_peppers: 3 }.\n\nAs an aside, notice that you can also assign the elements of the sub-array to individual block parameters, eg. food and amount. If only one parameter is specified, it will contain an array with two elements.\n\nBut Wait, There‚Äôs More!\n\nCheck out the plethora of other Enumerable methods in Ruby‚Äôs official documentation.\n\nCustom Enumerators\n\nWe‚Äôve seen a few examples of Enumerable‚Äôs awesomeness so far, but in my opinion its real power can only be truly experienced in combination with custom enumerators.\n\nLet‚Äôs say you‚Äôre writing a client that communicates with a search API. The API returns search results in pages (i.e. batches) of 50.\n\nclass SearchClient\n  def search_for(keywords, page: 1)\n    response = http_get('/search', keywords: keywords, page: page)\n    JSON.parse(response.body)\n  end\n\n  def http_get(path, **params)\n    ...\n  end\nend\n\n\nTo fetch all the search results, the caller makes multiple calls to the #search_for method.\n\nclient = SearchClient.new\npage = 1\n\nloop do\n  results = client.search_for('avocado', page: page)\n  break if results.empty?\n\n  results.each do |result|\n    # do something with search result\n  end\n\n  page += 1\nend\n\n\nThis approach works great, but forces the caller to understand how the API works. Specifically it requires the caller to know that results are paginated and that an empty result set indicates all results have been retrieved.\n\nLet‚Äôs move the pagination logic into a separate class.\n\nclass SearchClient\n  def search_for(keywords)\n    SearchResultSet.new(self, keywords)\n  end\n\n  def http_get(path, **params)\n    ...\n  end\nend\n\nclass SearchResultSet\n  attr_reader :client, :keywords\n\n  def initialize(client, keywords)\n    @client = client\n    @keywords = keywords\n  end\n\n  def each\n    page = 1\n\n    loop do\n      results = client.http_get('/search', keywords: keywords, page: page)\n      break if results.empty?\n\n      JSON.parse(results).each do |result|\n        yield result\n      end\n\n      page += 1\n    end\n  end\nend\n\n\nNotice how our SearchResultSet class transparently encapsulates the API‚Äôs pagination behavior. The caller no longer has to know how the API works. Instead, callers simply fetch results and iterate over them using a mechanism they‚Äôre already familar with - #each.\n\nHere‚Äôs an example.\n\nclient = SearchClient.new\nresults = client.search_for('avocados')\nresults.each do |result|\n  puts result['id']  # or whatever\nend\n\n\nMixing in Enumerable\n\nRemember when I said a bunch of Ruby‚Äôs core classes like Array and Hash include Enumerable? I meant that they quite literally include the Enumerable module.\n\nAnd because Enumerable is just a regular ‚Äòol Ruby module, you can include it too.\n\nIn fact, Enumerable was designed to be mixed into (i.e. included) into any Ruby class. The only requirement is that the class defines an #each method.\n\nThat‚Äôs because every other Enumerable method is implemented in terms of #each.\n\nYes, that‚Äôs right. Simply defining an #each method and includeing the Enumerable module into your class gives you all the power of Enumerable FOR FREE. In other words, you get #map, #each_slice, and all the other Enumerable methods without having to lift a finger.\n\nLet‚Äôs include Enumerable into our SearchResultSet class. With that very minimal effort, this is now possible:\n\nclient = SearchClient.new\nresults = client.search_for('avocados')\nids = results.map { |result| result['id'] }\n\n\nNotice that we didn‚Äôt define #map on SearchResultSet directly - it came from Enumerable. By the same token, #each_slice, #each_cons, #inject, and many, many other useful methods are now available too. What‚Äôs more, they all Just Work. Not bad for a few lines of code.\n\nThe Case of the Missing Block\n\nThere‚Äôs one last thing I‚Äôd like to talk about before wrapping up, and that‚Äôs lazy enumerators.\n\nWhat happens if we call SearchResultSet#each without a block?\n\nresults.each\n# =&gt; LocalJumpError: yield called out of block\n\n\nHmm, that‚Äôs weird. I don‚Äôt get an error if I try the same thing on an array:\n\n[5, 3, 8].each\n# =&gt; #&lt;Enumerator: [5, 3, 8]:each&gt;\n\n\nIn Ruby, the yield keyword doesn‚Äôt check to make sure the caller passed a block. We can therefore avoid the LocalJumpError by checking for the block, and bailing out if one wasn‚Äôt passed.\n\ndef each\n  return unless block_given?\n\n  page = 1\n  ...\nend\n\n\nOk, let‚Äôs try that again:\n\nresults.each\n# =&gt; nil\n\n\nNot quite what we wanted, but at least there‚Äôs no error. We need to figure out how to return the same kind of Enumerator object we got when calling a blockless #each on an array.\n\nKernel#to_enum\n\nFortunately, there‚Äôs an easy way to convert any function into an Enumerator - Ruby‚Äôs Kernel#to_enum.\n\ndef each\n  return to_enum(:each) unless block_given?\n\n  page = 1\n  ...\nend\n\n\nNow, calling SearchResultSet#each without a block will return an Enumerator object.\n\nresults.each\n# =&gt; #&lt;Enumerator: #&lt;SearchResultSet:0x00007fa715aaee70 @client=#&lt;SearchClient:0x00007fa715aaeec0&gt;, @keywords=\"avocado\"&gt;:each&gt;\n\n\nChaining Enumerators\n\nOk, so why do this? While not particularly important for the #each method, returning an Enumerator when called without a block is the way all the other Enumerable methods work. I think it‚Äôs a good idea to be consistent.\n\nAnother less important reason is to enable chaining. Enumerators respond to all the methods in Enumerable, meaning things like this are possible:\n\nenum = results.each\nenum.map.with_index do |result, idx|\n  # result is the search result, and idx is a counter automatically\n  # incremented on each iteration\nend\n\n\nConclusion\n\nEnumerators and the Enumerable module are my all-time favorite Ruby features. They are what got me hooked on Ruby when I first started using it back in 2011. No other language I‚Äôve used has been able to match the same level of expressiveness and flexibility.\n\nI hope this post inspires you to use Enumerable in new and interesting ways!"
        },
        {
          "id": "2021-08-14-installing-220-gems-in-40-seconds",
          "title": "Installing 220 Gems in 40 Seconds",
          "collection": {
            "label": "posts",
            "name": "Posts"
          },
          "categories": "",
          "tags": "",
          "url": "/2021/08/14/installing-220-gems-in-40-seconds/",
          "content": "I gave a lightning talk at RubyConf in 2017 about a gem I was working on at the time called prebundler.  I recently spent a bunch of time improving it, so I thought I‚Äôd write up a post.\n\nPublished on August 14th, 2021\n\nBack in 2017 I worked for Lumos Labs, the creators of Lumosity. We had recently transitioned from a custom Capistrano setup to Docker and Kubernetes for deploying our large Rails monolith. While we were pretty darn happy with it, the slowness of our Docker builds eventually became a major pain point. It would sometimes take over 30 minutes for CI to run, and while we used CI to run tests and a few other things as well, by far the most time-consuming part was building the Docker image. I decided to investigate.\n\nRight off the bat, I identified two major sources of slowness:\n\n\n  Building static assets.\n  Running bundle install.\n\n\nI‚Äôm going to focus on the second bullet point in this blog post.\n\nDocker vs Capistrano\n\nIn our Capistrano setup, installing gem dependencies was really fast, so we didn‚Äôt have to worry about it. That‚Äôs because Capistrano works by running commands on a remote machine over SSH. Every time you deploy, Capistrano runs bundle install for you. Most of the gems you need are already present on the machine from the previous deploy, so Bundler only has to fetch and install any new or upgraded ones.\n\nIn contrast, Docker images are built from scratch every time. In other words, Bundler has to fetch and install every gem every time you build a new container image. Depending on how many gems your app needs to run, this can take really long time. Considering that dependencies can themselves depend on other gems and so on, your app probably depends on a lot more than just what‚Äôs listed in your Gemfile. Furthermore, many popular gems contain native extensions - usually written in C - that need to be compiled during the installation process. Compilation time can add a significant amount of additional overhead.\n\nTime Lost\n\nIn April of 2017, the repo for lumosity.com (lumos_rails) contained 445 gem dependencies. That included both entries in the Gemfile and so-called transient dependencies, i.e. gems depended upon by other gems. It took our Travis CI builder job over six minutes to install them all inside the container image.\n\nSix minutes might not seem like a lot of time, but compounded over a month, a week, or even a single day, those 6 minutes add up quickly. Our team ran about 30 builds per day which translated into spending 3 hours a day, 15 hours a week, 60 hours a month just waiting for bundle install.\n\nBundler Improvements\n\nIn the not so distant past, Bundler introduced some nice new features for speeding up installation. For example there‚Äôs the handy --jobs n flag, which will install gems in parallel using n  threads. However only the I/O bound parts of installation are affected, since Ruby‚Äôs global VM lock (GVL) prevents multiple Ruby execution paths from running concurrently. Moreover, building native extensions is still a problem.\n\nWhat more can we do to speed things up?\n\nEnter Prebundler\n\nBack in 2017 I started thinking about ways to address the native extensions problem. It seemed like a waste of time to recompile extensions for every Docker build, especially considering the resulting .so files can be cached. Caching would have to be done outside of Docker though, since Docker only caches entire layers (i.e. the full result of a bundle install) and not individual gems.\n\nAfter some noodling, I came up with an idea: why don‚Äôt we stick all the gem‚Äôs files (including compiled native extensions, etc) into a TAR file and store it in some object storage system like S3? Installation would then be as simple as downloading the TAR file and expanding it onto the hard disk somewhere. All these operations are I/O bound, meaning the installation process can be highly parallelized.\n\nI coded up a solution and integrated it into lumos_rails. Our team saw bundle install time decrease from 6 minutes 7 seconds to 43 seconds - that‚Äôs an 88% speed up!\n\nPrebundling Discourse\n\nTo demonstrate the sort of speed-ups prebundler can enable, let‚Äôs take a look at the Gemfile from Discourse, a large, open-source Rails app.\n\nBy the way, all the code for this example can be found in the prebundler_bench repo.\n\nAt the time of this writing, Discourse has 220 direct and transient dependencies. Here‚Äôs a Dockerfile that installs all the gems from Discourse‚Äôs Gemfile without prebundler:\n\nFROM ruby:2.7\nWORKDIR /usr/src/app\nCOPY Gemfile* ./\nRUN bundle install --jobs $(nproc)\n\n\nNow, here‚Äôs a Dockerfile that uses prebundler instead:\n\nFROM ruby:2.7\nARG PREBUNDLER_ACCESS_KEY\nARG PREBUNDLER_ACCESS_SECRET\nWORKDIR /usr/src/app\nRUN gem install prebundler\nCOPY Gemfile* ./\nCOPY .prebundle_config ./\nRUN prebundle install --jobs $(nproc)\n\n\nFinally, here‚Äôs the contents of the .prebundle_config file:\n\nPrebundler.configure do |config|\n  config.storage_backend = Prebundler::S3Backend.new(\n    client: Aws::S3::Client.new(\n      region: 'default',\n      credentials: Aws::Credentials.new(\n        ENV['PREBUNDLER_ACCESS_KEY'],\n        ENV['PREBUNDLER_ACCESS_SECRET']\n      ),\n      endpoint: 'https://us-east-1.linodeobjects.com',\n      http_continue_timeout: 0\n    ),\n    bucket: 'prebundler',\n    region: 'us-east-1'\n  )\nend\n\n\nWe can now build the images like so:\n\n# regular installation using bundler\ndocker build \\\n    --no-cache \\\n    -f Dockerfile \\\n    -t prebundler_test:latest .\n\n# faster installation using prebundler\ndocker build \\\n    --no-cache \\\n    --build-arg PREBUNDLER_ACCESS_KEY=${PREBUNDLER_ACCESS_KEY} \\\n    --build-arg PREBUNDLER_ACCESS_SECRET=${PREBUNDLER_ACCESS_SECRET} \\\n    -f Dockerfile-pre \\\n    -t prebundler_test:pre-latest .\n\n\n\nNOTE: don‚Äôt forget to populate PREBUNDLER_ACCESS_KEY and PREBUNDLER_ACCESS_SECRET with the contents of your S3 credentials when you run the script.\n\nThe Results\n\nBuilding both images on my MacBook Pro produces the following output. The docker build command now helpfully times every operation, so we can see how long bundle install took vs prebundle install.\n\nHere‚Äôs the output for regular installation using bundler:\n\n[+] Building 185.7s (9/9) FINISHED\n =&gt; [internal] load build definition from Dockerfile   0.0s\n =&gt; =&gt; transferring dockerfile: 129B                   0.0s\n =&gt; [internal] load .dockerignore                      0.0s\n =&gt; =&gt; transferring context: 2B                        0.0s\n =&gt; [internal] load metadata for ruby:2.7              1.2s\n =&gt; [internal] load build context                      0.0s\n =&gt; =&gt; transferring context: 14.29kB                   0.0s\n =&gt; [1/4] FROM docker.io/library/ruby:2.7              0.0s\n =&gt; CACHED [2/4] WORKDIR /usr/src/app                  0.0s\n =&gt; [3/4] COPY Gemfile* ./                             0.0s\n =&gt; [4/4] RUN bundle install --jobs $(nproc)         179.2s\n =&gt; exporting to image                                 5.2s\n =&gt; =&gt; exporting layers                                5.2s\n =&gt; =&gt; writing image                                   0.0s\n =&gt; =&gt; naming to prebundler_test:latest                0.0s\n\n\nAnd here‚Äôs the output for installation using prebundler:\n\n[+] Building 48.3s (11/11) FINISHED\n =&gt; [internal] load build definition from Dockerfile   0.0s\n =&gt; =&gt; transferring dockerfile: 191B                   0.0s\n =&gt; [internal] load .dockerignore                      0.0s\n =&gt; =&gt; transferring context: 2B                        0.0s\n =&gt; [internal] load metadata for ruby:2.7              0.5s\n =&gt; [internal] load build context                      0.0s\n =&gt; =&gt; transferring context: 533B                      0.0s\n =&gt; [1/6] FROM docker.io/library/ruby:2.7              0.0s\n =&gt; CACHED [2/6] WORKDIR /usr/src/app                  0.0s\n =&gt; [3/6] RUN gem install prebundler                   3.3s\n =&gt; [4/6] COPY Gemfile* ./                             0.0s\n =&gt; [5/6] COPY .prebundle_config ./                    0.0s\n =&gt; [6/6] RUN prebundle install --jobs $(nproc)       39.9s\n =&gt; exporting to image                                 4.4s\n =&gt; =&gt; exporting layers                                4.4s\n =&gt; =&gt; writing image                                   0.0s\n =&gt; =&gt; naming to prebundler_test:pre-latest            0.0s\n\n\nAs you can see, bundler took 179.2 seconds while prebundler took only 39.9. That‚Äôs a 78% speed increase! Note that because we had to install the prebundler gem in a separate build step, the overall speed increase is actually closer to 74%. Pretty good, I‚Äôd say!\n\nSetting up Prebundler in your App\n\nAs you may have noticed, I used Linode‚Äôs object storage offering in the Discourse example above. As it happens, many of the object storage systems available from the various cloud providers are S3-compatible, requiring no changes to the example prebundler config I showed earlier.\n\nLet‚Äôs walk through the necessary steps one by one.\n\n\n  \n    First, you‚Äôll need a Linode account with object storage turned on. Linode charges a flat monthly fee under a certain storage limit. At the time of this writing, it costs $5/mo for 250gb of storage.\n  \n  \n    Create a bucket where all your TAR files will be stored. I called mine ‚Äúprebundler.‚Äù\n  \n\n\n\n\n\n  Create the access key prebundler will use to store and retrieve TAR files. It‚Äôs a good idea to give it only the access it needs, i.e. read and write access to the prebundler bucket only.\n\n\n\n\n\n  \n    Make sure to store the access key and secret in a secure location like a password manager or other credentials store.\n  \n  \n    Install prebundler by running gem install prebundler. If you‚Äôre using a Ruby version manager like rbenv or asdf, don‚Äôt forget to run rbenv rehash  or asdf reshim ruby to make the prebundle  command available in your PATH.\n  \n  \n    Create a .prebundle_config file in the root of your project and copy/paste in the configuration given above. Make sure to change the endpoint and region if you created your bucket in a region other than us-east-1.\n  \n  \n    Add two ARGs to your Dockerfile, one each for the access key and secret key. Add a COPY  directive to copy in the .prebundle_config, and finally RUN prebundle install instead of bundle install\n  \n  \n    Last but not least, build your Docker image. Don‚Äôt forget to pass two  --build-arg  arguments containing the access key and secret.\n  \n\n\nAfter building the image, you should see a bunch of TAR files in your object storage bucket:\n\n\n\nConclusion\n\nIf installing gem dependencies is slowing down your CI builds and blocking releases, consider giving prebundler a try. If you run into trouble, please don‚Äôt hesitate to file an issue or, better yet, submit a pull request :)"
        },
          {
            "id": "404.html",
            "title": "404 Not Found",
            "categories": "",
            "tags": "",
            "url": "/404.html",
            "content": "Page not found :(\nThe requested page could not be found."
          },
          {
            "id": "about",
            "title": "About",
            "categories": "",
            "tags": "",
            "url": "/about/",
            "content": "This is the basic Bridgetown site template. You can find out more info about customizing your Bridgetown site, as well as basic Bridgetown usage documentation at bridgetownrb.com\n\nYou can find the source code for Bridgetown at GitHub:\nbridgetownrb /\nbridgetown"
          }
]
